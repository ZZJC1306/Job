操作系统实验报告：作业调度程序
13061063郑若琳（组长）、13061064左佩璇、13061065贾美娟、13061066陈婉迪
1	需求说明
1.1	基本要求和提高要求
基本要求：10个调试任务，对程序进行调试。
提高要求：多级轮转反馈调度算法。
1.2	完成情况
实现所有基本要求和提高要求。
2	设计说明
2.1	提高要求实现说明
多级：定义struct waitqueue *head[3]，三个作业等待队列，队列的优先级与队列数组下标的关系是pri = i + 1。enq操作将作业按照defpri加入相应的队列，默认的defpri为1。
反馈：程序每运行一个时间间隔（即1秒），等待队列更新一次，非运行状态的全部作业等待时间加1s。等待时间大于等于10s时，优先级升一级，等待时间清零。将作业从原来的等待队列中拿出，重新链接原来的队列，并将该作业链接到新的等待队列的队尾。
轮转：当前作业的时间片到后，从高优先级的队列开始选择，若队列不为空，则选择队头元素，阻塞当前作业，运行选中的作业，实现作业切换。
不同队列不同时间片的实现：定义时间计数变量counttime，初值置为0。当切换置新的作业时，将counttime根据作业的curpri置成对应的时间片长度（5/2/1）。调度算法运行时，counttime不为0时只进行等待队列更新，不进行新作业的选择和切换。deq操作将作业出队时，置counttime为0，等待下一个时间间隔重新调度作业。
抢占式运行的实现：enq操作创建新作业，为作业创建新的进程并阻塞，并将新作业链接至相应优先级等待队列的队尾。若新作业的优先级大于当前正在运行的作业的优先级，选择新作业为下一个作业，进行作业切换，实现抢占。新作业优先级小于或等于当前作业优先级时不切换。
3	代码及运行结果：略
4	收获与感想
郑若琳：
这次的实验遇到的主要困难在于算法的调试。对照源码，完成改进的调度算法是比较顺利的。源码的思路非常清晰，可以看懂程序是怎样运行起来并实现调度作业的功能的。有关系统调用的比较难的部分源码中已经有了参考，只需要照着写并做一点修改就可以实现需要的功能。但是在写代码的过程中由于涉及的指针比较多，很多地方操作不当，导致最开始运行时每次都出现Segmentation fault (core dumped)，然后程序结束运行。只看这个错无法定位错误的位置，我又不太会在Linux系统下使用调试工具，所以只能开始到处printf，看程序是运行到哪里时出现的错误。最终发现问题，并成功修改。
感谢我的小伙伴们在算法调试阶段的陪伴和鼓励。四个人的团结协作使这次实验顺利了很多。感谢她们。
左佩璇：
这一次我分到的测试任务是在deq.c和stat.c里面查看当前cmdtype和owner，还有在updateall前后可以查看所有的信息，这两个都很简单，只要把代码读懂就基本上可以完成了。
关于调度算法我没有帮上什么忙，在查找bug的时候研究了一下代码，虽然bug不是我找出来的，但是在研究代码的过程中，也理解了算法。
贾美娟：
这次作业的基础调试部分相对简单一些，特别是在ppt样例的引导帮助下能相对轻松的完成任务；提高要求的多级抢占轮转算法比较难，这部分还都是组长大人写的，基本所有的函数都有改，写的很辛苦，组长大人棒棒哒，调试也是各种不顺，因为一个很宽泛的错误，我们对着代码盯了好久，最终发现了一个很隐蔽的问题（selset可能为null），感想主要是以后写代码还是要很仔细很细心的想到各种可能的错误情况，并及时的处理掉，不然出现的错误真的是好难找。
陈婉迪：
有了第一次实验痛苦挣扎的经历，再加上这次试验不是主要负责人，所以个人感觉比上一次实验轻松了许多。这次实验因为主要需要完成的是一个调度算法，所以代码主要都是由负责人完成的，但我们每个人都还是将整个实验弄懂了，理解了的。
虽然自己感觉轻松了，但这次实验也并不是一帆风顺的，代码写到后面一直有bug没有调出来，但我们四个人还是一直坚持，互相鼓励，解决了问题。 
附：会议记录
5.3：讨论源码，分配任务
5.6：各自阅读源码之后，提出各自的问题并讨论，开始各自完成调试任务
5.8：调试调度算法
分工：
基本要求：调试任务1-4：郑若琳
		  调试任务5-6：左佩璇
		  调试任务7-8：贾美娟
		  调试任务9-10：陈婉迪
提高要求：多级轮转反馈调度算法：郑若琳
		  协助调试：左佩璇、贾美娟、陈婉迪

